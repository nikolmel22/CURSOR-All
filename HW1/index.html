<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>Homework #0</title>
</head>
<body>
    <header>
        <h1>Домашнє завдання: GIT</h1f>
    </header>

    <section>
        <div class="subsection">
            <h2>Base</h2>
                <p>
                    <b>
                        (!) Домашнє завдання потрібно здавати у вигляді сторінки на GITPAGES
                    </b>
                    <a href="https://youtu.be/HzB1zcmamIk">
                        Відео про те, як здавати ДЗ
                    </a>
                </p>
                <br>

                <p>
                    
            Створити локальний репозиторій добавити index.html сторінку закомітати. Створити віддалений репозиторій на
            github, підключити локальний до віддаленого і налаштувати github pages.
        
                </p>
                <p>
                    Додати в цю html сторiнку шпаргалку за командами гита.
                    Перелік основних команд з якi потрібно записати:
                </p>
                <ul>
                    <li>git config --global user.name blabla-наше ім'я яке буде видиме при коміті в репозиторій</li>
                    <li>git config --global user.email blabal@bla-пошта, яка буде видима при коміті в репозиторію</li>
                    <li>git init-ініціює пустий репозиторій в поточній директорії. Так само можна вказати будь-який шлях.</li>
                    <li>git status-Команда git status показує стану файлів в робочій директорії і індексі: які файли змінені, але не додано в індекс; які очікують коммітов в індексі. Додатково до цього виводяться підказки про те, як змінити стан файлів.</li>
                    <li>git add .–Команда додає вміст робочої директорії в індекс (staging area) для подальшого коммітов. За замовчуванням  використовує лише цей індекс, так що ви можете використовувати git add для збірки зліпка вашого наступного коммітов.</li>
                    <li>git commit-Команда git commit бере всі дані, додані в індекс за допомогою git add, і зберігає їх зліпок у внутрішній базі даних, а потім зрушує покажчик поточної гілки на цей зліпок.        </li>
                    <li>git log-перечисляє комміти, укладені в репозиторії в обратному хронологічному порядку - останні комміти знаходяться вверху.</li>
                    <li>git checkout-файли копіюють файли со сценами в робочий каталог. Ету команду зручно використовувати, щоб переглядати небажані зміни в робочих директоріях.</li>
                    <li>git branch-це свого рода "менеджер веток". Вона вміє перечисляти ваші вітки, створювати нові, віддаляти і переіменовувати їх.</li>
                    <li>git push origin master–Пушим або відправляємо в репозиторій наші зміпки проекту. </li>
                    <li>git pull origin master–команда для отримання змін з репозиторію.</li>
                    <li>git merge-використовується для злиття однієї або кількох векторів у поточній.</li>
                    <li>git clone-це утиліта командної строки Git для вибору існуючого репозиторію та створення його клону, т. е. копії.</li>
                </ul>
                        <li> gitignore Позволяет не мучаться с выбором нужных файлов для индексации (которая git add).</li>
                        
                        <p>В большом проекте часто бывает много файлов, которые не подлежат версионированию. Свою лепту вносят редакторы и среды разработки, компиляторы, дебаггеры, прочие инструменты и сама операционная система. А ещё вам может быть удобно хранить какие-то промежуточные результаты в папке tmp.
                        
                        Настройка .gitignore позволяет не выискивать нужные файлы, а добавлять всё сразу или по крайней мере уточнять меньше. Соглашусь с комментарием Etki, подход "просто выбрать нужные" совершенно не масштабируется.</p>
                        
                        <li> Сделать локальный конфиг, который не будет затронут pull-ом.</li>
                        
                        <p> Предположим, для работы вашего проекта нужен конфиг. Значения в нем зависимы от места выполнения, погоды и настроения разработчика.
                        
                        Вариант 1: сделать local.conf и вносить изменения при необходимости. Если вы его вдруг добавите и закоммитите, то у вас будут конфликты при pull/push. Или с пуллом к вам придёт чужой конфиг.
                        
                        Вариант 2: версионируемый local.conf.example и игнорируемый local.conf. В работе используется второй, для его формирования вручную или автоматически используется первый. Хорошо, удобно и не препятствует автоматизации. У меня так конфигурируются автотесты, запускаемые локально и на сервере интеграции.</p>
                        
                        <li> Защитить чувствительную информацию от случайного раскрытия.</li>
                        
                        <p>Случается, что вы случайно добавили и закоммитили ключи или пароли от какого-нибудь облачного хранилища, например Amazon. А потом запушили это добро на GitHub. Что нужно делать в такой ситуации? Очень быстро бежать и менять все ключи и пароли, т.к. почти наверняка за ваш счёт уже майнятся биткойны.
                        
                        Если так уж необходимо хранить чувствительную информацию в папке проекта, то нужно положить её в под-папку, игнорируемую git.</p>
                        
                        <li> Быстро очищать проект от временных файлов.</li>
                        
                        <p>  Предположим, что вы пишете на компилируемом языке и при построении вашего проекта формируется множество промежуточных файлов (объектные, прекомпиляция, вот это всё). Перед каждой сборкой необходимо их удалять, чтобы в случае чего не прилинковать лишнее. Можно делать это вручную. Можно написать скрипт. А можно просто добавить их в .gitignore и делать так:
                        
                        git clean -fX</p> </li>
                </ul>

                    </div>

        <div class="subsection">
            <h2>Advanced</h2>
                <P>
                    Записати такi команди:
                </P>

                <ul>
                    <li>git revert-З'ясовує які зміни потрібно скасувати, скасовує їх і створює новий Комміт, в якому ці зміни проведені.</li>
                    <li>git reset-Скидає індекс, але не робочий дерево. Це означає, що всі ваші файли не пошкоджені, але будь-які відмінності між вихідним коммітов і вихідним коммітов будуть відображатися як локальні зміни (або файли без відстеження) зі статусом git.</li>
                    <li>git rebase-ще один спосіб перенести зміни з однієї гілки в іншу. Rebase стискає всі зміни в один «патч». Потім він інтегрує патч в цільову гілку. На відміну від злиття, переміщення перезаписує історію, тому що вона передає завершену роботу з однієї гілки в іншу        </li>
                    <li>git cherry pick-використовується для перенесення окремих коммітов з одного місця сховища в інше, зазвичай між гілками розробки та обслуговування. Цей механізм відрізняється від звичних команд git merge і git rebase, які переносять коммітов цілими ланцюжками</li>
                    <li>git stash-дозволяє на час «здати в архів» (або відкласти) зміни, зроблені в робочій копії, щоб ви могли застосувати їх пізніше. Відкладання змін корисно, якщо вам необхідно перемкнути контекст і ви поки не готові до створення коммітов.        </li>
                  </ul>
                   <p> <a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">
                    Підключити github через SSH
                </a></p>
        </div>

    </section>

   <script src="./00hwtest.js"></script>
    
</body>
</html>
